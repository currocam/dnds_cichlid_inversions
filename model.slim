initialize() {
	initializeSLiMModelType("nonWF");
	// *Set up genetics*
	// Mutation types
	initializeMutationType("m1", 0.5, "f", 0.0); // non-coding
	initializeMutationType("m2", 0.5, "f", 0.0); // synonymous
	c(m1, m2).convertToSubstitution = T;
	initializeMutationType("m3", 0.5, "f", 0.0); // non-synonymous (and deleterious)
	m3.color="red";
	// non-synonymous (and conditionally adaptive
	initializeMutationType("m4", 0.5, "f", 0.0);
	m4.color="green";
	c(m3, m4).convertToSubstitution = F;
	// We'll consider the fitness being a function of the conditionally adaptive
	// and deleterious mutations such that
	// f(X, Y, p1) = (1 - s_D)^Y * ( 1 - s_C1)^X * (1 - \epsilon1)^(X(1-X)/2)
	// f(X, Y, p2) = (1 - s_D)^Y * ( 1 + s_C2)^X * (1 + \epsilon2)^(X(1-X)/2)
	defineConstantIfNotThere("TARGET_X", 25);
	defineConstantIfNotThere("s_D", 0.001);
	defineConstantIfNotThere("s_C1", 0.001);
	defineConstantIfNotThere("s_C2", 0.01);
	defineConstantIfNotThere("epsilon1", -0.001);
	defineConstantIfNotThere("epsilon2", 0.001);
	// We simulate a random chromosome structure with exons, introns and non-coding regions
	// We consider introns to be evolving strictly neutral
	// (so they are modelled as non-coding regions)
	initializeGenomicElementType("g1",  m1, 1); // non-coding
	// coding regions inside and outside the inversion
	// Proportions were chosen so we would expect 30.9% of synonymous 
	// and 69.1% of nonsynonymous substitutions to happen under purely
	// neutral evolution (Pond, Frost, and Muse 2005)
	defineConstantIfNotThere("FRACTION_S", 0.309);
	defineConstantIfNotThere("FRACTION_D", 0.600);
	defineConstantIfNotThere("FRACTION_C", 0.091);
	assert((FRACTION_S+FRACTION_D+FRACTION_C) - 1.0 < 1e-6);
	initializeGenomicElementType("g2", c(m2, m3, m4), c(FRACTION_S, FRACTION_D, FRACTION_C));
	// Now, we define the inversion location
	defineConstantIfNotThere("L", 11e6);
	defineConstantIfNotThere("INV_LENGTH", 1e7);
	defineConstantIfNotThere("INV_START", asInteger(L/2 - INV_LENGTH/2));
	defineConstantIfNotThere("INV_END", INV_START + INV_LENGTH - 1);
	// Set up chromosome structure
	// Recombination
	defineConstantIfNotThere("SCALING", 5); // Linear scaling factor
	defineConstantIfNotThere("RHO", 1e-8); // Recombination rate
	defineConstantIfNotThere("MU", 1e-8); // Number of chromosomes
	initializeRecombinationRate(0.5*(1-(1-2*RHO)^SCALING));
	setUpChromosome(L);
	// We'll keep track of the inversion with some special mutations
	initializeMutationType("m5", 0.5, "f", 0.0); // start-inversion
	initializeMutationType("m6", 0.5, "f", 0.0); // end-inversion
	c(m5, m6).convertToSubstitution = F;
	c(m5, m6).color = "blue";
	// Demographic history
	// We simulate two populations of constant size N1 and N2 
	// and symmetric migration rate m
	defineConstantIfNotThere("K1", 2000);
	defineConstantIfNotThere("K2", 2000);
	defineConstantIfNotThere("MIGRATION", 0.01);
	// Other parameters
	defineConstantIfNotThere("BURNIN", 200);
	defineConstantIfNotThere("RUNTIME", 10000);
	defineConstantIfNotThere("LOGGING", 1);
}
// We handle fitness manually
mutationEffect(m3) { return 1.0; }
mutationEffect(m4) { return 1.0; }

reproduction() {
	n_offspring = rpois(1, 10);
	if (n_offspring>0)
		subpop.addCrossed(individual, subpop.sampleIndividuals(1), count=n_offspring);
}

// Before burnin, no adaptive mutation can arise
1:BURNIN mutation(m4) {
	// Convert into deleterious mutation
	mut.setMutationType(m3);
	return mut;
}

modifyChild() {
	if (child.genome1.countOfMutationsOfType(m4)>TARGET_X)
		return F;
	if (child.genome2.countOfMutationsOfType(m4)>TARGET_X)
		return F;
	return T;
}


// After the establishment of the desired haplotype
// no adaptive mutations can arise
T1+1: mutation(m4) {
	// Convert into deleterious mutation
	mut.setMutationType(m3);
	return mut;
}


// Initialize popoulations
1 early() {
	// save this run's identifier, used to save and restore
	defineConstant("simID", getSeed());
	sim.addSubpop("p1", asInteger(K1));
	sim.addSubpop("p2", 0);
	// Logging
	if (LOGGING == 0)
	{
		log = community.createLogFile("/dev/stderr", logInterval=500);
		log.addCycle();
		log.addCustomColumn("Pop1", "p1.individualCount;");
		log.addCustomColumn("Pop2", "p2.individualCount;");
		log.addCustomColumn("Maximum count m4", "maxNumberHaplotype(m4);");
		log.addCustomColumn(
			"Frequency inversion P1",
			"mean(p1.individuals.countOfMutationsOfType(m5));"
			);
		log.addCustomColumn(
			"Frequency inversion P2",
			"mean(p2.individuals.countOfMutationsOfType(m5));"
			);
	}
}

1: early() {
	// Migration
	if (MIGRATION>0)
	{
		migrants = p1.sampleIndividuals(
			rpois(1, p1.individualCount*MIGRATION)
			);
		if (migrants.size()>0)
			p2.takeMigrants(migrants);
		// Migration from p2 to p1:
		if (p2.individualCount>0)
		{
			migrants = p2.sampleIndividuals(
				rpois(1, p2.individualCount*MIGRATION)
				);
			if (migrants.size()>0)
				p1.takeMigrants(migrants);
		
		}
	}
	// non-overlapping generations
	inds = sim.subpopulations.individuals;
	inds[inds.age > 0].fitnessScaling = 0.0;
	// Population 1 (original)
	inds = p1.individuals;
	inds = inds[inds.age == 0];
	Y = inds.countOfMutationsOfType(m3);
	X = inds.countOfMutationsOfType(m4);
	inds.fitnessScaling = (1-s_D)^Y * ( 1 - s_C1)^X * (1-epsilon1)^(X*(1-X)/2);
	p1.fitnessScaling = K1 / inds.size();
	
	// Population 2 (derived)
	inds = p2.individuals;
	inds = inds[inds.age == 0];
	Y = inds.countOfMutationsOfType(m3);
	X = inds.countOfMutationsOfType(m4);
	//inds.fitnessScaling = (1-s_D)^Y * ( 1 + s_C2)^(X-TARGET_X*2) * (1-epsilon2)^(X*(1-X)/2-TARGET_X*2*(1-TARGET_X*2)/2);
	inds.fitnessScaling = (1-s_D)^Y * ( 1 + s_C2)^X * (1-epsilon2)^(X*(1-X)/2);
	// We scale the fitness such that p2 reaches 
	// its carrying capacity when optimal haplotype
	p2.fitnessScaling = K2 / (
		inds.size() *  (1 + s_C2)^(TARGET_X*2) * (1-epsilon2)^(TARGET_X*2*(1-TARGET_X*2)/2)
		);
}

2: first() {
	// Check if an individual from p2 has the desired number of adaptive alleles
	inds = sim.subpopulations.individuals;
	inds.tagL0 = inds.genome1.countOfMutationsOfType(m4) == TARGET_X;
	inds.tagL1 = inds.genome2.countOfMutationsOfType(m4) == TARGET_X;
	candidates = c(
		p1.sampleIndividuals(1, tagL0=T),
		p1.sampleIndividuals(1, tagL1=T),
		p2.sampleIndividuals(1, tagL0=T),
		p2.sampleIndividuals(1, tagL1=T)
		);
	if (candidates.size()>0)
	{
		defineConstant("T1", sim.cycle);
		// save the state of the simulation
		sim.outputFull(tempdir() + "slim_" + simID + ".txt");
		
		founder = sample(candidates, 1);
		inverted = ifelse(
			founder.genome1.countOfMutationsOfType(m4) == TARGET_X,
			founder.genome1,
			founder.genome2
			);
		inverted.addNewDrawnMutation(m5, INV_START);
		inverted.addNewDrawnMutation(m6, INV_END);
		catn("#T1: " + T1, error=T);
		p2.takeMigrants(founder);
		community.deregisterScriptBlock(self);
	}
}

T1+1 : first() {
	// Every 10 ticks, check if inversion have been lost
	if (sim.cycle % 10 == 0)
	{
		// Sanity check
		inv_start = sim.subpopulations.individuals.countOfMutationsOfType(m5);
		inv_end= sim.subpopulations.individuals.countOfMutationsOfType(m6);
		assert(all(inv_start==inv_end));
		
		// Check if inversion was lost
		if (sum(inv_start)== 0)
		{
			catn("#Inversion was lost after less than " + (sim.cycle-T1) + " generations!", error=T);
			// Go back to T1
			sim.readFromPopulationFile(tempdir() + "slim_" + simID + ".txt");
			// start a newly seeded run
			setSeed(rdunif(1, 0, asInteger(2^62) - 1));
			// re-introduce the inversion
			inds = sim.subpopulations.individuals;
			inds.tagL0 = inds.genome1.countOfMutationsOfType(m4) == TARGET_X;
			inds.tagL1 = inds.genome2.countOfMutationsOfType(m4) == TARGET_X;
			candidates = c(
				p1.sampleIndividuals(1, tagL0=T),
				p1.sampleIndividuals(1, tagL1=T),
				p2.sampleIndividuals(1, tagL0=T),
				p2.sampleIndividuals(1, tagL1=T)
				);
			founder = sample(candidates, 1);
			inverted = ifelse(
				founder.genome1.countOfMutationsOfType(m4) == TARGET_X,
				founder.genome1,
				founder.genome2
				);
			inverted.addNewDrawnMutation(m5, INV_START);
			inverted.addNewDrawnMutation(m6, INV_END);
		}
	}
}

RUNTIME late() {
	assert(exists("T1"));
	genomes = c(
		p1.sampleIndividuals(100).genomes,
		p2.sampleIndividuals(100).genomes
		);
	genomes.outputVCF(filePath="/dev/stdout");

}


// Handle inversion when it appears
recombination() {
	gm1 = genome1.containsMarkerMutation(m5, INV_START);
	gm2 = genome2.containsMarkerMutation(m5, INV_START);
	if (!(gm1 | gm2)) {
		// homozygote non-inverted
		return F;
	}
	inInv = (breakpoints > INV_START) & (breakpoints <= INV_END);
	if (sum(inInv) % 2 == 0) {
		return F;
	}
	if (gm1 & gm2) {
		// homozygote inverted
		left = (breakpoints == INV_START);
		right = (breakpoints == INV_END + 1);
		breakpoints = sort(c(breakpoints[!(left | right)],
			c(INV_START, INV_END + 1)[c(sum(left) == 0, sum(right) == 0)]));
		return T;
	} else {
		// heterozygote inverted: resample to get an even # of breakpoints
		// this is *recursive*: it calls this recombination callback again!
		breakpoints = sim.chromosome.drawBreakpoints(individual);
	}
	return T;
}

// Generate random genes along an approximately L
// bases chromosome
function (void)setUpChromosome(integer$ size) {
	initializeGenomicElement(g1, 0, INV_START);
	rates = c(0.0);
	ends = c(INV_START);
	base = INV_START+1;
	while (base < INV_END) {
		// make a non-coding region
		nc_length = rdunif(1, 100, 5000);
		initializeGenomicElement(g1, base, base + nc_length - 1);
		rates = c(rates, 0.0);
		ends = c(ends, base + nc_length - 1);
		
		base = base + nc_length;
		// make first exon
		ex_length = asInteger(rlnorm(1, log(50), log(2))) + 1;
		initializeGenomicElement(g2, base, base + ex_length - 1);
		rates = c(rates, MU*SCALING);
		ends = c(ends, base + ex_length - 1);
		
		base = base + ex_length;
		// make additional intron-exon pairs
		do
		{
			in_length = asInteger(rlnorm(1, log(100), log(1.5))) + 10;
			initializeGenomicElement(g1, base, base + in_length - 1);
			rates = c(rates, 0.0);
			ends = c(ends, base + in_length - 1);
			
			base = base + in_length;
			ex_length = asInteger(rlnorm(1, log(50), log(2))) + 1;
			initializeGenomicElement(g2, base, base + ex_length - 1);
			rates = c(rates,  MU*SCALING);
			ends = c(ends, base + ex_length - 1);
			
			base = base + ex_length;
		}
		while (runif(1) < 0.8);
		// 20% probability of stopping
	}
	// final non-coding region
	initializeGenomicElement(g1, base, size);
	rates = c(rates, 0.0);
	ends = c(ends, size);
	initializeMutationRate(rates, ends);

}

// Helper function for debugging
function (integer)maxNumberHaplotype(o<MutationType>$ mutType) {
	genomes1 = sim.subpopulations.individuals.genome1;
	genomes2 = sim.subpopulations.individuals.genome2;
	return max(c(
		max(genomes1.countOfMutationsOfType(mutType)),
		max(genomes2.countOfMutationsOfType(mutType))
		));
}

function (void)defineConstantIfNotThere(string$ symbol, * value) {
	if (!exists(symbol))
		defineConstant(symbol, value);
}
